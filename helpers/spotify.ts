/* note: this file are generated by chatgpt */

import { Buffer } from 'node:buffer'
import { TOTP, Secret } from 'otpauth'
import { Feed } from 'feed'

const { fromHex } = Secret

const R1 = (x: string) => x + 'ify'
const R2 = (x: string) => `https://${x}.${R1('spot')}.com`
const CLIENT_VERSION = '1.2.78.309.g316d2f2f'
const REFERER = `${R2('open')}/`
const MIKO = 35
const MI = 3
const KO = 5
const MIKU = MIKO + MI * KO + MI * (KO - MI) + KO
const UA =
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36'

function genRandomMd5(): string {
  const buf = Buffer.alloc(16)
  crypto.getRandomValues(buf)
  return buf.toString('hex')
}

export function getSanityIdAt(timestamp: number) {
  // I tried but GenAI just does not seem to be imaginative
  const mikoCode = atob(
    'MzMzNzM2MzEzMzM2MzMzODM3MzUzMzM4MzQzNTM5MzgzOTMzMzgzODMzMzMzMTMyMzMzMTMwMzkzMTMxMzkzOTMyMzgzNDM3MzEzMTMyMzQzNDM4MzgzOTM0MzQzMTMwMzIzMTMwMzUzMTMxMzIzOTM3MzEzMDM4'
  )
  const totp = new TOTP({
    algorithm: 'SHA1',
    period: 30,
    digits: 6,
    secret: fromHex(mikoCode),
  })
  return totp.generate({
    timestamp,
  })
}

function getSanityStatement() {
  const timeMs = Number(new Date())
  const totp = getSanityIdAt(timeMs)
  return {
    reason: 'init',
    productType: 'web-player',
    totp,
    totpServer: totp,
    totpVer: MIKU,
  }
}

export function getSanityToken(): Promise<string> {
  const sanityStatement = getSanityStatement()
  const base = new URL(`${R2('open')}/api/token`)
  for (const [key, val] of Object.entries(sanityStatement)) {
    base.searchParams.set(key, String(val))
  }
  return fetch(base)
    .then((x) => x.json())
    .then((x) => {
      if (!x.accessToken) {
        throw new Error('No sanity token')
      }
      return x.accessToken
    })
}

function getClientToken(): Promise<string> {
  return fetch(`${R2('clienttoken')}/v1/clienttoken`, {
    method: 'POST',
    headers: {
      'User-Agent': UA,
      Accept: 'application/json',
      'Accept-Language': 'en-US,en;q=0.5',
      'content-type': 'application/json',
      'Cache-Control': 'no-cache',
    },
    referrer: REFERER,
    body: JSON.stringify({
      client_data: {
        client_version: CLIENT_VERSION,
        client_id: 'd8a5ed958d274c2e8ee717e6a4b0971d',
        js_sdk_data: {
          device_brand: 'unknown',
          device_model: 'unknown',
          device_id: genRandomMd5(),
          device_type: 'computer',
          os: 'windows',
          os_version: 'NT 10.0',
        },
      },
    }),
  })
    .then((x) => x.json())
    .then((x) => x.granted_token.token)
}

class SpotifyUtils {
  #initialized = false
  #clientToken = ''
  #sanityToken = ''

  async ensureInit() {
    if (this.#initialized) return

    this.#clientToken = await getClientToken()
    this.#sanityToken = await getSanityToken()
    this.#initialized = true
  }

  #buildRequestHeader() {
    return {
      Accept: 'application/json',
      'Accept-Language': 'en',
      authorization: `Bearer ${this.#sanityToken}`,

      'content-type': 'application/json;charset=UTF-8',
      'client-token': this.#clientToken,
      [`${R1('spot')}-app-version`]: CLIENT_VERSION,
      'app-platform': 'WebPlayer',
      'User-Agent': UA,
      Referrer: REFERER,
      Origin: REFERER,
    }
  }

  #buildFetchPlaylistQuery(uri: string, offset: number, limit: number) {
    const url = new URL(
      [R2(['api', 'partner'].join('-')), 'pathfinder', 'v2', 'query'].join('/')
    )
    const body = {
      extensions: {
        persistedQuery: {
          version: 1,
          sha256Hash:
            'bb67e0af06e8d6f52b531f97468ee4acd44cd0f82b988e15c2ea47b1148efc77',
        },
      },
      operationName: 'fetchPlaylist',
      variables: {
        uri,
        offset,
        limit,
        enableWatchFeedEntrypoint: false,
      },
    }
    return fetch(url, {
      headers: this.#buildRequestHeader(),
      body: JSON.stringify(body),
      method: 'POST',
    })
  }

  async *getSpotifyPlaylist(playlistId: string) {
    let totalCount = Infinity
    let offset = 0
    const limit = 25

    while (offset < totalCount) {
      const payload = await this.#buildFetchPlaylistQuery(
        `${R1('spot')}:playlist:${playlistId}`,
        offset,
        limit
      ).then((x) => {
        if (x.ok) {
          return x.json()
        }
        throw x
      })

      if (totalCount === Infinity) {
        totalCount = payload.data.playlistV2.content.totalCount
      }
      yield* payload.data.playlistV2.content.items
      offset += limit
    }
  }

  async buildSpotifyPlaylist(playlistId: string, feed: Feed) {
    await this.ensureInit()
    let itemCount = 0

    for await (const i of this.getSpotifyPlaylist(playlistId)) {
      const {
        addedAt: { isoString },
      } = i
      const { uri, name, artists } = i.itemV2.data

      const artistNames = artists.items
        .map((x: any) => x.profile.name)
        .join(', ')
      feed.addItem({
        id: uri,
        title: `${name} by ${artistNames}`,
        date: new Date(isoString),
        link: [R2('open'), ...uri.split(':').slice(1)].join('/'),
        description: `New release by ${artistNames}: "${name}"`,
        author: artists.items.map((x: any) => ({
          name: x.profile.name,
        })),
      })
      itemCount += 1
      if (itemCount > 15) {
        break
      }
    }
  }
}

export default new SpotifyUtils()
